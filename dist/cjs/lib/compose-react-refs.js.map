{"version":3,"file":"compose-react-refs.js","sources":["../../../src/lib/compose-react-refs.ts"],"sourcesContent":["// @see https://github.com/seznam/compose-react-refs\nimport { MutableRefObject, Ref } from \"react\"\n\ntype OptionalRef<T> = Ref<T> | undefined\n\nexport function composeRefs<T>(...refs: [OptionalRef<T>, OptionalRef<T>, ...Array<OptionalRef<T>>]): Ref<T> {\n  if (refs.length === 2) {\n    // micro-optimize the hot path\n    return composeTwoRefs(refs[0], refs[1]) || null\n  }\n\n  const composedRef = refs\n    .slice(1)\n    .reduce(\n      (semiCombinedRef: OptionalRef<T>, refToInclude: OptionalRef<T>) => composeTwoRefs(semiCombinedRef, refToInclude),\n      refs[0],\n    )\n  return composedRef || null\n}\n\ntype NonNullRef<T> = NonNullable<Ref<T>>\nconst composedRefCache = new WeakMap<NonNullRef<unknown>, WeakMap<NonNullRef<unknown>, NonNullRef<unknown>>>()\n\nfunction composeTwoRefs<T>(ref1: OptionalRef<T>, ref2: OptionalRef<T>): OptionalRef<T> {\n  if (ref1 && ref2) {\n    const ref1Cache = composedRefCache.get(ref1) || new WeakMap<NonNullRef<unknown>, NonNullRef<unknown>>()\n    composedRefCache.set(ref1, ref1Cache)\n\n    const composedRef =\n      ref1Cache.get(ref2) ||\n      ((instance: T): void => {\n        updateRef(ref1, instance)\n        updateRef(ref2, instance)\n      })\n    ref1Cache.set(ref2, composedRef)\n\n    return composedRef as NonNullRef<T>\n  }\n\n  if (!ref1) {\n    return ref2\n  } else {\n    return ref1\n  }\n}\n\nfunction updateRef<T>(ref: NonNullRef<T>, instance: null | T): void {\n  if (typeof ref === \"function\") {\n    ref(instance)\n  } else {\n    ;(ref as MutableRefObject<T | null>).current = instance\n  }\n}\n"],"names":[],"mappings":";;;AAKO;AACL;AAEE;AAA2C;AAG7C;AAEG;AACgH;AACzG;AAEV;AACF;AAGA;AAEA;AACE;AACE;AACA;AAEA;AAGI;AACA;AAAwB;AAE5B;AAEA;AAAO;AAGT;AACE;AAAO;AAEP;AAAO;AAEX;AAEA;AACE;AACE;AAAY;AAEX;AAA8C;AAEnD;;"}